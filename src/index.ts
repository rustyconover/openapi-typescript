import path from "path";
import prettier from "prettier";
import parserTypescript from "prettier/parser-typescript";
import load from "./load";
import { swaggerVersion } from "./utils";
import { transformAll } from "./transform/index";
import { OpenAPI2, OpenAPI3, SchemaObject, SwaggerToTSOptions } from "./types";
export * from "./types"; // expose all types to consumers

export const WARNING_MESSAGE = `/**
* This file was auto-generated by openapi-typescript.
* Do not make direct changes to the file.
*/


`;

export default async function openapiTS(
  schema: string | OpenAPI2 | OpenAPI3 | Record<string, SchemaObject>,
  options?: SwaggerToTSOptions
): Promise<string> {
  // 1. load schema
  const schemaObj = await load(schema, { auth: options?.auth, silent: options?.silent || false });

  // 2. determine version
  const version = options?.version || swaggerVersion(schemaObj as OpenAPI2 | OpenAPI3);

  // 3. generate output
  let output = WARNING_MESSAGE;
  const types = await transformAll(schemaObj, {
    formatter: options && typeof options.formatter === "function" ? options.formatter : undefined,
    immutableTypes: (options && options.immutableTypes) || false,
    rawSchema: options && options.rawSchema,
    version,
  });
  for (const [k, v] of Object.entries(types)) {
    if (typeof v === "string") {
      output += `export interface ${k} {\n  ${v}\n}\n\n`;
    }
  }

  // 4. Prettify output
  let prettierOptions: prettier.Options = {
    parser: "typescript",
    plugins: [parserTypescript],
  };
  if (options && options.prettierConfig) {
    try {
      const userOptions = prettier.resolveConfig.sync(path.resolve(process.cwd(), options.prettierConfig));
      prettierOptions = {
        ...(userOptions || {}),
        ...prettierOptions,
        plugins: [...(prettierOptions.plugins as prettier.Plugin[]), ...((userOptions && userOptions.plugins) || [])],
      };
    } catch (err) {
      console.error(`‚ùå ${err}`);
    }
  }
  return prettier.format(output, prettierOptions);
}
